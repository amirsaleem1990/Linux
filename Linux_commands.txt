# multitasking in one shell.
# eg: when we start jupyter from terminal we can't use that terminal until we kill the jupyter, so instead of <jpyter-lab>  type  <jupyter-lab &> ............ now you can use that terminal for other command too.
#  list all files, size mesure = MB ................... ls -l --block-size=M
# remove not empty folder ................... rm -r folder_name/
# Move a window to a different workspace .................... Super+Shift+Page Up ................ Super+Shift+Page Down
---------------------------------
# all 
Go to /sys/class/net you can see list of folders here.
find wireless interface. It has wireless folder. for example in my case is wlp10 you can check it using ls wlp10. if the folder's name different use that folder's name.
sudo iwlist wlp1s0 scan | grep ESSID
---------------------------------
#####################
Wildcards *
#####################
a*.txt
# matches all file names that start with a lowercase letter a and end with .txt.
---------------------------------
# If you want files that start with an uppercase A or a lowercase a and end with .txt, use the expression
[Aa]*.txt
# This expression would match the following files:
--------------------------------
# You can use the star more than once — for example, with the expression a*v*.txt. This expression would match only one file in the example list of files:
# among file: [a.txt, a_very_long_name.txt, A_FILE_NAME_WITH_UPPERCASE_LETTERS.txt]
a_very_long_name.txt
--------------------------------
ls /usr/lib/l*z*.a
# list of all files in path /user/lib/ that starts with <l> and contain <z> and fileExtention <.a>
--------------------------------
ls /usr/lib/l*[AFLz]*.a
# list of all files in path /user/lib their names starts with <l>, and contains at least one of the <A, F, L, z] and ending with <.a>
--------------------------------
count all files with .py extention in current folder ................... ls *.py | wc
# count all files in current folder ................... ls | wc
# count all files in current folder and his childrens subfolders ................... find . | wc
# count all files with .py extention in current folder and his childrens subfolders ................... find . -name "*.py" | wc
# list all files with *.py in current folder and his chidrens subfolders. ................... find . -name "*.py"
---------------------------------
NOTE: If you deleted the file using the command line, the file has been permanently deleted. Files that have been permanently deleted can’t be recovered from the Trash.
# unzip / extract zip file ................... unzip file.zip
# unzip tar.gz file ................... tar xvzf file.tar.gz
# unzip and remove bz2 file ................... bzip2 -d file.bz2
# If you want to extract bz2 file and keep the original, run this command: ................... bzip2 -dk file.bz2
---------------------------------
How to search for text string on multiple files?
find . -type f -print | sed 's/ /\\ /g' | xargs grep -i "my text string"
[    What that does:
    Find everything in the current directory or any of its children which is a regular file.

    Convert spaces in filenames to escaped spaces so the grep won't fail.

    xargs converts the line-separated list of items from the find into a space separated list for the grep.

    grep -i is searching while ignoring capitalization for "my text string" 

    Help stamp out MBR partition tables. Use GPT instead!
https://ubuntuforums.org/showthread.php?t=1722145]
---------------------------------
create alias for terminal ................... alias p="ipython"
# ab jab bhi terminal par <p> likh kar enter karun ga to ipython khul jay ga, magar ye srif isi session tak valid h, jesy hi terminal band ho ga ye alias bhi remove ho jay ga, ksi bhi alias ko perminently use karny k lye usy ~/.bashrc file me append karty hen.
# To see all the aliases defined in the environment: ................... alias
# To remove an alias, the unalias command is used, like so: ................... unalias alias_name
---------------------------------
# nautilus bookmark editing
# first: open the file
gio open .config/gtk-3.0/bookmarks
# then edit this file
---------------------------------
# save text[currently in clipboard] in file ................... xclip -o > new_file_name.txt
# Put the contents of the selection into a file. ................... xclip -t text/html index.html
# save text to file ................... echo "my name is amir" > file_name.txt
---------------------------------
# save image[currently in clipboar] in file ....................... xclip -selection clipboard -t image/png -o > file.png
# this command is vary big, hence hard to type every time, so we can create an alias of this command,
alias si="xclip -selection clipboard -t image/png -o >"
# now we type like thi: si image_15
# save this alias from perminent use: echo 'alias si="xclip -selection clipboard -t image/png -o >"' >> ~/.bashrc && source ~/.bashrc
---------------------------------
# list of all files in current folder, with size and date, sorted by time, most early on top ................... ls -l  -S --sort=time -r
# suspend ................... pm-suspend ................ sudo pm-suspend ....................systemctl suspend
# hibernate ................... pm-hibernate ----------------- or: sudo pm-hibernate ................... or: systemctl hibernate
# How Do I Put My Computer To Sleep After a Certain Amount Of Time? ...................... echo 'pm-suspend' | at now + 30 minutes ................ or: echo 'systemctl suspend' | at now + 30 minutes
# pichly folder ki files list ................... ls ..
# agly folder ki list ................... ls folder_name_in_current_directory
# foxit alias ................... alias foxit='/home/home/opt/foxitsoftware/foxitreader/FoxitReader'
# close terminal shortcut ................... CTLR+D
# zip folder <Sentiment140> to file <Sentiment140.zip> ................... zip -r Sentiment140.zip Sentiment140/
# zip files ................... zip imtiaz-list.zip imtiaz-list.*
# get file size ................... du -sh file or folder name
---------------------------------
#alias for rm remove
#if you remove file or folder using terminal the removed file deleted perminantily, if we do mistake we can't restore our file, so we need alias, this alias move the file Trash folder.
alias rm='mv -t ~/.local/share/Trash/files'
---------------------------------
# for count videos duration in particuler foler ................... for f in *.mp4; do ffmpeg -i "$f" 2>&1 | grep Duration | cut -d " " -f 4 | sed s/,//  | tr -d "\n" && echo " $f"; done
---------------------------------
# read first n lines from file ................... head -5 R.r
# read all file in terminal ................... cat file_name
---------------------------------
# my very usefull aliases:
alias si='xclip -selection clipboard -t image/png -o >'
alias foxit='/home/home/opt/foxitsoftware/foxitreader/FoxitReader'
alias rm='mv -t /home/home/Desktop/Trash/'
alias cc="gcc p1.c -o p1 && ./p1"
alias jp="jupyter-notebook"
alias copyfrom="xclip -sel cli <"
alias copyto="xsel -b >"
alias rm="rm -i"
alias calc="gcalccmd" # terminal calculator

#Note: these aliases should be writen in the end of file bashrc, opeh this file by (subl ~/.bashrc), and in the end of the file paste these lines, save file, exit, and then type on terminal (source ~/.bashrc)
----------------------------
# copy file contant to clipboard ................... xclip -sel cli < file_name
NOTE: if you use (>) rather then (<) then all file contant will be removed. so give this command your attention.
----------------------------
# create a new file with cantant in clipboard. ................... xsel -b > some.txt
# add lines to end of file ................... echo 'VNCSERVERS="1:root"' >> filename ................ echo "blablabla blablabla blablabla >> filename
# copy file from another direcotry to currect directory ................... cp /blabla/blabla/bla.txt . # this <.> mean current directroy
# ls for current and subdirectories ................... ls *
-------------------------
combine two commands whith && or ;
let us say you need to creat a derctory <folder> and then go into that directory, usually we solve this problam by two commands in two lines, we can write these two commands in one line saparated by <&&>: so <mkdir folder> and then in next line <cd folder/>  is equal to: <mkdir folder && cd folder/> and same as: <mkdir folder ; cd folder/>
--------------------------
> remove everything in file and add current input. eg: ls > a.txt............  yahan agar a.txt exist nahi karti ho gi to ban jay gi or us me <ls> ka result save ho jay ga. or agar file exist karti ho gi to us ka sara contant delete ho jay ga or <ls> ka result us me save ho jay ga.

>> append k lye >> use hota h. eg: ls >> b.txt ...............  yahan, agar b.txt exist karti ho gi to us k aakhir me <ls> ka result save ho jay ga, or agar nahi exist karti ho gi to new file ban jay gi jis me <ls> ka result save ho jay ga.
create empty file: ............... > a.txt
murge +1 files: ................... cat file_1.txt, file_2.txt... file_n.txt > new_file.txt................... now new_file.txt contain contant of all n files.
--------------------------
for creating a small text file, we should use cat.
let us see we need to store one line text in file. usually we done this job by oppining the text editor, typing our line and save the file, we can do the same via cat. so:
cat > file.txt
# now want to type what we want to store, after typing we press CTRL+D. now we have file named file.txt contain text that we typed between <cat > file.txt> and <CTRL+D)
--------------------------
# cout file lines: ............... wc -l filename
# go to folder in home directory ............... cd ~/Desktop/ .............. it is equal to cd /home/amir/Desktop/ 
# google search query ............... firefox google.com/search?q="query you want"
# only lines that contains specific text ............... cat file_name.txt | grep text_you_want_to_search
# only files that contain (statistics) in these names ............... du -sh *statistics*
# all files and files in folders only  ............... ls  */
# only folder names not files ............... ls -d */
# files sorted by extention, so .py first and .txt after  ............... ls | rev | sort | rev
# second way:  ...............  ls -lX
# zip 2 or more files ............... zip final.zip file1 file2 file_n

### WIFI
# refresh wifi list .......................... iwlist scan
# connected wifi details ................... nmcli dev wifi
# saved wifi connections:  ............... nmcli c
# check available WiFi hotspots after refresh  ............... iwlist scan && nmcli d wifi list ............... 
# To see list of interfaces ............... ifconfig -a
# wifi - graphical interface in shell  ............... nmtui
# turn on/off wifi  ............... <nmcli radio wifi on> or <nmcli networking on> ............... <nmcli radio wifi off> or <nmcli networking off>
# all saved wifi ............... cd /etc/NetworkManager/system-connections && ls
# if you want to see datails of any saved wifi here:  ............... sudo cat /etc/NetworkManager/system-connections/your_wifi_name | grep psk=
# connect to saved wifi ............... nmcli connection up your_wifi_name ...............  nmcli -a c up your_wifi_name
# open only first ten jpg files ................... gio open $(ls *.jpg | head)
# only lines with particuler keyword in all .txt files ........................... cat $(find . -name *.txt) | grep amir
# grep with one before and after with mached line ...................... cat $(find . -name *.py) | grep -B1 -A1  your-sub-string
# dissconnect current wifi ................ nmcli con down wifi_name
# connect to unknow wifi .................. nmcli device wifi connect <AP name> password <password> .... Note: if you connect to a network using this command the password will no show in wifi setting.
# nmcli --ask connection up wi-fi



# grep with more than one words .................. grep 'text1\|text2' github/Linux/linux_commands.txt
# Search all text files with grep ............ grep 'word*' *.txt
# Search all python files for 'wordA' or 'wordB' .................. grep 'wordA*'\''wordB' *.py ............ grep -E 'word1|word2' *.doc .............. grep -e string1 -e string2 *.pl ................ egrep "word1|word2" *.c
# To just match words, add the -w option: ...................... grep -w 'warning\|error\|critical' /var/log/messages ........... Note: here we find for words, so if there an words matches then we get our result, we need 'warning' so if 'warnings' not appear in the result though 'warning' in 'warnings'.
---------------------------------------------
# grep commands https://www.cyberciti.biz/faq/searching-multiple-words-string-using-grep/
grep 'word1\|word2\|word3' /path/to/file
# Search all text files ..................... grep 'word*' *.txt
# Search all python files for 'wordA' or 'wordB' ..................... grep 'wordA*'\''wordB' *.py .....................grep -E 'word1|word2' *.doc ..................... grep -e string1 -e string2 *.pl .....................egrep "word1|word2" *.c
# In this example, search warning, error, and critical words in a text log file called /var/log/messages, enter: ..................... grep 'warning\|error\|critical' /var/log/messages
# To just match words, add the -w option: ..................... grep -w 'warning\|error\|critical' /var/log/messages
# Use the egrep command and you can skip the above syntax to search three words: ..................... egrep -w 'warning|error|critical' /var/log/messages ..................... grep -e 'warning|error|critical' /var/log/messages
# I recommend that you pass the -i (ignore case) and --color option as follows too: ..................... egrep -wi --color 'warning|error|critical' /var/log/messages
# To search all *.conf files under /etc/, enter: ..................... egrep -wi --color 'foo|bar' /etc/*.conf
# To search recursively (including sub-directories) listed, run: ..................... egrep -Rwi --color 'foo|bar' /etc/
---------------------------------------------
# while loop .................. while :; do sleep 3; ls newFolderForPictures/ | wc ; done .. explaination: sleep 3 seconds, then print files qty. in folder newFolderForPictures, do not stop this loop until any problums accur.
 determine which process is monopolizing or eating the CPUs.  ..................... ps -eo pcpu,pid,user,args | sort -k 1 -r | head -10 ------------------- ps -eo pcpu,pid,user,args | sort -r -k1 | less 
# ls only folders size ............. du -sh $(ls -d */)
# cpu usage ................................ nmon
# multiple terminals in one screen ........................... tmux ............ CTRL+B SHIFT+% ............... CTRL+B D ...................... tmux new -s assig_a_name ................. tmux a -t assig_a_name ............... 
# install .deb file from terminal ........... sudo dpkg -i example.deb
# unzip .tar file ....................... tar xvf file_name.tar
# ls output to array and then slice this array , for learning by watching series of videos stored in HDD ............... array=($(ls -1)) ..... this is one time only, then : vlc ${array[0]} ........... change <0> for each video.
# open muliple links in firefox saved in .txt file .................... firefox $(cat your_text_file_name.txt)
# download package using pip with no installation ..................... pip download package_name
# download package using apt-get with no installation .................... apt-get download PACKAGE && apt-cache depends -i PACKAGE | awk '/Depends:/ {print $2}' | xargs  apt-get download 
# check dependencies ....................... apt-get -s install packagename ....................... apt-cache depends package-name ......................... dpkg -I your_package.deb
# execute python command from terminal .................. python -c "print(5/6)"     
# list of recently installed packages ............................. zcat -f /var/log/dpkg.log* | grep "\ install\ " | sort
# list of recently installed packages ............................. zcat -f /var/log/dpkg.log* | grep "\ install\ " | sort
# terminal commands history: history
#  You can quickly run a command again by typing the number preceded by an exclamation mark ( ! ) character. For example, to run the command numbered 3 in the history list, you can type !3 and press the Enter key.
# local host par kya chal raha h?: nmap localhost
# Open current foler from terminal: nautilus .
# create folder from terminal: mkdir foder_name .................. if you write a name without " " and use space in your folder name than ubuntu will create a folders eg: <mkdir amir noman hassan> create 3 folders and  <mkdir "amir noman hassan"> will create one folder
# create txt file and open it in one command from terminal: subl file.txt .................  if sublime exist in your computer, else: gedit file_name
# open picture in full mode ............ eog -f file_path
# open file (almost for any file type): gio open file_path
# run video on vlc without interface: cvlc video_file_name
-------------------------------
# tmux .... multiple terminals in one window
start tmux ............ tmux

add new split in bottom side .............. CTRL+B SHIFT+"
add new split in right ................ CTRL+B SHIFT+%
go to left side window .............. CTRL+B LEFT-ARROW
go to right side window ............... CTRL+B RIGHT-ARROW
go to upper window .................. CTRL+B UPPER+ARROW
go to bottom window ................. CTRL+B BOTTOM+ARROW
----------------------------------
#ubuntu_folder_shortcut: press Ctrl + Shift + drag/drop the icon
------------------------------------

#shutdown: poweroff ............. or: shutdown -h no
#current window screenshot and copy to clipboard: gnome-screenshot -w -c
# selected area screenshot  and copy to clipboard: gnome-screenshot -a -c
# create password protected zip file ................. zip --encrypt secure.zip your_file
# zip -r output.zip input_folder/ ; zip --encrypt secure.zip output.zip
# find all files except those have end with .py  .................. find . -not -name "*.py"
# calculator using python and alias ........................................ alias p="python3 -c 't=input(); print(eval(t))'"
# list all files except files with .txt or .pdf .......................... ls -I "*.txt" -I "*.pdf"
# eject usb ............. first: sudo fdisk -l ,this will be return devices, select your device name eg: /dev/sdb1 (NOTE: this is require sudo, alternavily we use lsblk, this do the same but withoud need to sudo)......... second: sudo eject your_device_name
# convert .mkv file to .mp4 .................. sudo ffmpeg -i *.mkv -codec copy output.mp4 
# search in pdf ......................... pdfgrep -i -H -n data learning/ISLR/ISLR.pdf.......... <-i> ignore case, <-H> with file name, <-n> with page number .................... 
# search in pdf ......................... find /path -name '*.pdf' -exec sh -c 'pdftotext "{}" - | grep --with-filename --label="{}" --color "your pattern"' \; <https://stackoverflow.com/questions/4643438/how-to-search-contents-of-multiple-pdf-files>
# google search alias shortcut ........................alias g='read a; firefox google.com/search?q="$a"'
# create directory and go inside it ...................... function mkcd() { mkdir $1; cd $1 ;}
# kill process .................... pkill application_name
# find file ................. locate "*.pdf" ............ if regex not specified then assume "*keyword*" 
# locate file ......... is command sy sari files jin k name me <file> ho ga kahin bhi or ksi bhi case me wo sab aa jaen gi. .......................... it is equal to : find . -iname "*file*", but the latter is very very slow................ NOTE: The locate command is not perfect, however. Sometimes the results of locate can be overwhelming, giving you too much information. Also, locate uses a database that is usually only updated once a day, so if you just created a file a few minutes or a few hours ago, it might not appear in this list until the next day. It’s worth knowing the disadvantages of these basic commands so you can better decide when best to use each one.
# last modified file or folder in particuler directory ............................ ls -t github/Linux/ | head -1
# only files not folder ........................... ls -p | grep -v /
# mute video without voice .......................... ffmpeg -i input.mp4 -vcodec copy -an output.mp4
# mute audio from mp3 file from only specific portions ........................ ffmpeg -i *.mp3  -af "volume=enable='between(t,5,10)':volume=0, volume=enable='between(t,15,20)':volume=0" ok.mp3
-------------------------
# Bash Bang (!) Commands
!top 		– execute the most recent command that starts with ‘top’ (e.g. !).
!top:p 		– displays the command that !top would run (also adds it as the latest command in the command history).
!$ 			– execute the last word of the previous command (same as Alt +., e.g. if last command is ‘cat tecmint.txt’, then !$ would try to run ‘tecmint.txt’).
!$:p 		– displays the word that !$ would execute.
!* 			– displays the last word of the previous command.
!*:p 		– displays the last word that !* would substitute.
!^ - first argument (after the program/built-in/script) from previous command
!! - previous command (often pronounced "bang bang")
!n - command number n from history
!pattern - most recent command matching pattern
!!:s/find/replace - last command, substitute find with replace

---------------------------
# create nested directories ...................... mkdir -p some/other/directories
# to know pdf file pages qty ............................... pdfinfo file.pdf| grep 'Pages:'
# battery status: upower -i /org/freedesktop/UPower/devices/battery_BAT0| grep -E "state|to\ full|percentage"
# current date only: date '+%d-%m-%y' ........... date +%F
# current time only: date +%I:%M%p
# yesterday date: date -d "1 day ago" '+%Y-%m-%d'
# last command in history starts with <emg> ............... !emg

# ignore case in <find> ................. -iname, eg: find . -iname keyword.

$ get previous command argument ant put into new command, eg: touch amir-saleem-file.txt. this is our first command, here <touch> is command, and <amir-saleem-file.txt> is an argument, if we need to use this argument in next line, thy typical way to use it by typing entire argument one more time, but there is shortcut which is <!$> or <ALT + .>, so in second line type: <subl !$> or <subl ALT + .>, both are equelent to: <subl amir-saleem-file.txt>
# gnome-terminal in fixed size ....................... gnome-terminal --geometry 130x3+0+0 .............. gnome-terminal --geometry=widthxheight+Xposition+Yposition
# open picture / image from coomand line in fixed size and place .............. feh image.png ..... pdf file laptop me read karny k lye  foxit-reader use karta hn, lamba time parhni hoti h to eyes ki protection k lye backgroud ko black and text ko green kar leta hn. magar  header ka color linux waly foxit me change nahi hota, to is lye ye kara k aik picture banai, jis ka address ye h (~/Dropbox/pics/while-reading-pdf-on-15inch-laptop.png), or 1 alias banaya h (alias pdf="(feh ~/Dropbox/pics/while-reading-pdf-on-15inch-laptop.png &) ; exit"), jab is alias ko run karta hn to header ko black picture cover kar leti h. or masla hal :p ..................... pichly solution me kuch masla aa raha tha is lye 1 bash file (pdf) banai, or us ko /bin/ me copy kar dye or us ka mode change kar dye (chmod x+ pdf)

# the output of <find> contain lots of <permission denied ......... > massages, to avoid these masseges use: < -readable> option, eg: <find . -readable -name "*.pdf"> instead of <find . -name "*.pdf">

# <gopen> == <geo open>
# for loop example: for i in *.txt ; do echo $i ; cat $i ; echo "
> " ; done
...... 
# convert all .ipynb files to .py files ....................... for i in *.ipynb; do ipython nbconvert --to=python $i ; done
# remove all file AND folders that contains in their names <ipy> AND <check> ................. rm -r -f $(find $(find . -iname "*ipy*") -name "*check*")
# system monitor .............. gnome-system-monitor ..........
......
# split one large .xml file to multiple .xml files
xml_split -l 1 *.xml
......
# find
# Find a file or directory on the system using this command
# Find a file myfile.txt in current directory and its subdirectories-----------------find . -name “myfile.txt”
# Find all files in current directory that are larger than 1GB ..................... find . -size  +1G
# Find all .doc files on the system that have been modified in the last 5 days.--------------find . –name “*.doc” –mtime -5
# Find all .txt files on the system that were modified in last 15 minutes-----------------------find . –name “*.txt” –mmin -15
# Find all files that contain a string “I am inside file”.------------find . -name "*" -exec grep -i -H "I am inside file" {} \;
---------------
# grep
# This command is used to search all the lines in all files in a specified location containing a string.
Search for a specific string “myname” in a file myfile.txt -----------------grep “myname” myfile.txt
Search for a specific string “myname” with ignoring the case in a file myfile.txt -----------------grep -i “myname” myfile.txt
Search for a specific string “myname” in a all files in current directory -----------------grep “myname” *
Search for full word “myword” in a file myfile.txt -----------------grep -w “myword” myfile.txt
Search a string “myname” in all files in all subdirectories recursively -----------------grep -r “myname” *
---------------
# chmod
# The command for manipulating the file permissions For better security, the permissions for file in Linux OS are categorized into different groups, users and other sections. You have the option of controlling the permissions by assigning the users under the given divisions via the command of ‘chmod’. These permissions would help the users to write, read and execute the respective files. This option is very much handy when you have to run a script in order to install the package, which remains non executable in the default for security reasons. With the command of ‘chmod +x’ you could end up making the script executable over your Linux system.

# Provide execute permission on a file myfile.txt to all users ----------------chmod +x myfile.txt
# Provide read permission on a file myfile.txt to all users ----------------chmod +r myfile.txt
# Provide full permissions (read/write/execute) on a file myfile.txt to yourself but everyone else has only read and execute ----------------chmod 755 myfile.txt
# Provide full permissions (read/write/execute) on a file myfile.txt to everyone ----------------chmod 777 myfile.txt 





# passwd --------------- change your password

# kill / terminate process--------------- see list of currently running applications by <ps -al>, note <PID> number of application which you want to kill, and finally <kill -9 your_noted_PID_number>


# all .ipynb files that contain <rpart> ------------------ find . -name *.ipynb | xargs grep -s "rpart"



# get file name from user and using this name save picture (which is in the clipboard) ............ read v; si $v.png .......... Note: <si> here alias for copy screen shot to clipboard


#===========================================================
data scince csv file manupulation on bash
# count file lines ---------------- wc -l adult.data
# count file words ---------------- wc -w adult.data 
# first 2 lines of file ---------------- head -n 2 adult.data 
# header not exist in file, so we need to add header ----------------first: echo "col_1, col_2, col_3, col_n, " > header.csv .......... 2nd: cat header.csv adult.data > adult.csv
# replace particuler text by onather ---------------- sed "s/<string to replace>/<string to replace it with>/g" <source_file> > <target_file> ............ eg: grep ", ?," adult.csv | wc -l ................. privious command tell us how many rows that contain at least one "?" ...... no we need to replace this "?" by empty string so: ................... sed "s/, ?,/,,/g" adult.csv >  adult.csv.
# subset large file, we need 20 lines from 100 till 120 ---------------- head -n 120 adult.csv | tail -n 20 > adult_sample.csv
# Finding duplicates with uniq ---------------- counts the number of duplicated lines---------------- sort adult.csv | uniq -d | wc -l
# this takes the output of all lines with added repetition counts, sorts in reverse and outputs the first 3 duplicates ---------------- sort adult.csv | uniq -c | sort -r | head -n 3
# only 2nd column ---------------- cut -d "," -f 2 adult.csv
# uniques ant its counts in 2cnd column---------------- cut -d "," -f 2 adult.csv | sort | uniq -c
# loop over all file names, replace each space (in file name) by under score ---------------- replace_source=' '; replace_target='_'; for filename in ./*.csv; do new_filename=${filename//$replace_source/$replace_target}; mv "$filename" "$new_filename"; done
# https://www.datacamp.com/community/tutorials/shell-commands-data-scientist
#===========================================================
# ignore first line ............... cat filename | sed 1d > filename_without_first_line.............. application: mery pas kafi csv file thin, jin k header same thy, mujhy un sab ko 1 hi file banani thi, leking headar exclude kar k, to me ny pehly 1 new file banai jis me srif 1 header daal dya, or phir loop chala kar har file (exclude header) us new file me append kar dya ...................... for i in *.csv ; do cat $i | sed 1d >> ../all_data_in_one_file.csv; done

# convert file chracter set .......... iconv -f ISO-8859-1 -t UTF-16//TRANSLIT input.txt -o output.csv


# csv column qty ------------------ head -1 file.csv | sed 's/,/\t/g' | wc -w
# split large file in small files .................. split -C size_you_want(like: 300K, 50M, 1G) --numeric-suffixes input_file output_prefix
# string to binary ............. echo AB | perl -lpe '$_=unpack"B*"' 
# binary to string ............ echo 0100000101000010 | perl -lpe '$_=pack"B*",$_'
# binary to text ............... strings fileanme
# ignore / exclude certien files /extentions from <ls> ................... ls -I "*.st*"
# open file/app in fix sized window and fix location in screen ................. subl && sleep 3 && wmctrl -r :ACTIVE: -e 0,0,0,1960,660" ............... sleep command to load file properly and then change its size and place, so we can not remove sleep from this command.
unzip tar.xz file ........... tar xf file.tar.xz
unable an application; suppose i need no one can use firefox; first i type <which firefox> this will return a directory where firefox application file is located, now it is /usr/bin/ , second: i am open the file <sudo gedit /usr/bin/firefox> and then add this line <exit> on top (after #!/bin/bash line), and save it. now if  some one try to open firefox via command line or GUI  nothing happen, becouse the file </usr/bin/firefox> when executes and execute first line (which is <exit> ) it is exit.
# get input from user with prompt ................. read -p "Enter your Name: " variable_name 
# open picture file [in kali linux] ................. eog picture_file_name
# set application to defaul ..................... mimeopen -d your_file ......... and then chose option to set it default, next time you will be able to use: mimeopen your_file
# general file openor for kali linux ................. xdg-open file_name
# create bootable usb from command line ............... sudo dd if=iso_file_path of=/dev/sdd bs=4M
webcam application ............. cheese
# motherboard model ................ sudo dmidecode -t baseboard | grep -i 'Product'
# protect folder / asking for root user ................. chmod 600  folder/
copy from vim to another application .............. Position the cursor where you want to begin copying ............ Press v to select characters, or uppercase V to select whole lines ................. Move the cursor to the end of what you want to cut .............. press: "+y .............. now the text on your clipboard
#conver .m4a to .mp3 ...................... ffmpeg -v 5 -y -i input.m4a -acodec libmp3lame -ac 2 -ab 192k output.mp3
# connect to Linux_server using ssh ................ ssh server_user_name@ip .......... eg: ssh lfd-server@192.168.8.104
# copy file from local to host ........................ scp b.txt lfd-server@192.168.8.114: ................................ this command will copy file from my computer to lfd-server on sepecified ip address at home dirctory  .................... scp pdf lfd-server@192.168.8.114:Desktop/pdff ................... this last command will copy at Destkop by name <pdff>
# last modifided/created .ipynb file in whole system ....................... ls -lt $(find . -name "*.ipynb") | head
# extract specifice range of pages from pdf file ................. pdftk input_file.pdf cat 12-15 output outfile_p12-15.pdf
# pdf OCR .................... ocr file.pdf ................. ocr is bash file: https://github.com/amirsaleem1990/Linux/blob/master/ocr
# replace dosts <.> in filename with <_>.................. a=a.b.c.d.pdf ; mv a.b.c.d.pdf "${a//\./_}"
# git commit large file ...................... git filter-branch -f --index-filter 'git rm --cached --ignore-unmatch large_file_name_with_path'

Ctrl+U: This clears the entire line so you can type in a completely new command.
Ctrl+K: This deletes the line from the position of the cursor to the end of the line.
Ctrl+W: This deletes the word before the cursor only.

# If you just want to see what the last cat command was, you can instead run: 
!cat:p

Another common problem is mistyping the command you want to run. Say you wanted to run nano, but accidentally typed nanp:
nanp /path/to/a/document/buried/deep/in/the/filesystem
Instead of retyping the whole thing, you could just run:
^nanp^nano

Expansions
When you're working with variations of a file—like backups or different file types—it can get tedious typing out the same commands with small tweaks. Using the brace symbols ({}), you can easily perform batch operations on multiple versions of a file.
Say you want to rename just part of a filename. Instead of typing out mv /path/to/file.txt /path/to/file.xml, you could just run:
mv /path/to/file.{txt,xml}
This runs the command with the same arguments, only with the parts inside the brace changed—the first part corresponding to the first argument, the second part corresponding to the second argument.


The braces can also work when moving or creating multiple files at once. For example, if you wanted to create three numbered directories, you could just run:
mkdir myfolder{1,2,3}
This will create three folders: myfolder1, myfolder2, and myfolder3.4


# .ts to .mp4 ................. ffmpeg -i file.ts -c:v libx264 file.mp4

# open pdf file in linux default pdf viwer which is called (document viewer) ............... evince file.pdf
# str slicing ................ a=$(ls *.part); echo "${a:52:1}" # print 1 element from variable a from index 52.
# du output sorted by size (in MB) .............. du -sh -B M * | sort -nr
# ignore case in ls ................. first type: shopt -s nocaseglob.............. within your current session of terminal you are ignoring CASE

# chromium current open tabls urls ............... cat -e /home/amir/snap/chromium/849/.config/chromium/Default/'Current Session' | sed -e 's/\^@/\n/g' -e '/_\/chrome/d' | grep -Po '(http|https)://\K.*' | sort -u ............... https://askubuntu.com/questions/970546/location-of-the-urls-of-the-open-tabs-of-chromium-browser-in-ubuntu
# a=$(ls /home/amir/.g| sort -rn| head -1); b=$(expr $a + 1); xsel -b > /home/amir/.g/$b
# list only hidden files/folders ....................... ls -d .?*
# dissable wifi. NOTE: aftter this you can\t use wifi until you restart ..................... sudo airmon-ng check kill
# cron job for shutdown computer at 18:30 each day ............. open (as root) /etc/crontab, then add this line in the end <30 18   * * *   root    poweroff>
# whereis ......... If you’re looking for a binary file, you can use the whereis command to locate it. This command returns not only the location of the binary but also its source and man page if they are available......... NOTE: the <which> command only returns the location of the binaries in the PATH variable.
# apt package dependencies ................... apt-cache showpkg your_package_name
# ls -R provides subdirectory names and the names of files within subdirectories
# print text file(without empty lines) with line number ............... nl file_name ........... cat -b file_name 
# print text file(with empty lines) with line number ............... cat -n file_name
# starting from particuler line to the end ......................... tail -n+80 file_name ....... this will return all file except first 78 lines
# replace every occurrence of mysql with MySQL and then save the new file to file_2.txt.....  sed s/mysql/MySQL/g file_1.txt > file_2.txt
# If you wanted to replace only the first occurrence of the term mysql, you would leave out the trailing <g> command ......... sed s/mysql/MySQL/ file_1.txt > file_2.txt
# If you wanted to replace only say third occurrence of the term mysql ......... sed s/mysql/MySQL/3 file_1.txt > file_2.txt
# change IP ............. ifconfig interface new_ip_address ................ eg: ifconfig eth0 192.168.181.115
# moniter which application using internet ............. sudo nethogs ............. sudo netstat -lantp | grep -i stab | awk -F/ '{print $2 $3}' | sort | uniq
# baaz dafa esa hota h k aap ko <apt> sy package install karna hota h, jab aap <apt-get install package_name> run karty hen to koi result nahi aata, or system us package_name ko nahi pehchanta, to is ko hal karny ka pehla step ye h k ye run karen <apt-cache seach package_name>, agar is command k output me aap ka matooba package_name h, t wohi command chalaen <apt-get install package_name>, ab install ho jay ga.


# string indexing ........... a=amirsaleem; echo ${a:1:9}


# remove all history .................. HISTSIZE=0


# if else condition ........... test $HOME = "/root"; if [ $? -eq 0 ]; then HOME=/root; fi ............ explaination: pehly test ho ga k <$HOME> equal to "/root" h ya nahi, agar True ho ga to <$?> me 0 store ho jay ga else 0, phir ham check kar rahy hen hen k <$?> equal to <0> h ya nahi(integer comparison> , agar <0> ho (yani $HOME equal to "/root" ho> to ham HOME ka new variable banaen gy.


disk mount when system is start ................ me ny optical Drive ki jaga second HDD lagai hwi h, jb me system on karta hun to masla ye hota h k wo HDD automatic mount nahi hoti, pehly me usy mount karta hun phir usy use kar sakta hun , .......... SOLVED: go to <disk>, select your second HDD <in my case>, click on <additional partition options>, select <Mount options>, enable <User Session Defaults>, and check <Mount at system startup>.........


#----------------------------------------
# rotate video
# Rotate 90 clockwise:
ffmpeg -i in.mov -vf "transpose=1" out.mov

# For the transpose parameter you can pass:
# 0 = 90CounterCLockwise and Vertical Flip (default) 
# 1 = 90Clockwise 
# 2 = 90CounterClockwise 
# 3 = 90Clockwise and Vertical Flip

# Flip the input video horizontally.
# For example to horizontally flip the video in input with `ffmpeg':
ffmpeg -i in.avi -vf "hflip" out.avi
#----------------------------------------


# exit with 0 status <in bash script> ............. exit 0

# get only unique files extentions .................. for f in *.*; do printf "%s\n" "${f##*.}"; done | sort -u


# extract files from .ISO file ............... mkdir ISO ; sudo mount your_iso_file.iso ISO/; cd ISO ..........

# solved (bash terminal display arabic in reverse order)

# add these lines to ~/.bashrc file and source it 
if ! [[ "$(ps -p $(ps -p $(echo $$) -o ppid=) -o comm=)" =~ 'bicon'* ]]; then
  bicon.bin
fi


# git push count since yesterday ........... git rev-list HEAD --count --first-parent --since=$(date --date="1 day ago" +%F)

# output of lsblk have a loot of unnecessary loog devices (Snap packages), to avoid them, use: lsblk -e 7

# mount partition in <read only> mode ............... sudo mount -r /dev/sdb5 /media/500GB

# format usb to ext4 type .................. sudo mkfs.ext4 /dev/sdc

# nmcli d w c ZONG\ MBB-E5573-D164 password $(sudo cat /etc/NetworkManager/system-connections/ZONG\ MBB-E5573-D164 |  grep psk= | sed 's/psk=//g')

# release swap memory .................... sudo swapoff -a ; sudo swapon -a
# update only one package .................. apt-get install --only-upgrade <packagename>

# top list process than consume some CPU for user <amir> ............. top -i -u amir

# check your public ip address ............. curl ifconfig.me OR curl icanhazip.com OR curl ipecho.net/plain OR curl ident.me OR curl bot.whatismyipaddress.com OR curl https://diagnostic.opendns.com/myip OR curl http://checkip.amazonaws.com



# stop service .............. sudo systemctl stop service_name
zip files and remove orignals .................. zip -rm aa.zip *

# only folders size .............. du -sh ./*/

############################
start and end time 
start=`date +%s` 
end=`date +%s`
runtime=$((end-start))
echo $runtime
############################
get only numbers .............. echo "I am 999 years old." | tr -dc '0-9'

unrar .rar file in linux ............ unrar  e  file.rar .

------------------------------
# http://blog.chapagain.com.np/ubuntu-linux-increase-decrease-volume-from-command-line-keyboard-shortcut/
CONTROLE VOLUME
amixer is a command-line mixer for ALSA soundcard driver.
Increase volume by 10% ------------     amixer set 'Master' 10%+
Decrease volume by 10% ------------     amixer set 'Master' 10%-
Set volume to 10%      ------------     amixer set 'Master' 10%
Set volume to 80%      ------------     amixer set 'Master' 80%
------------------------------

# convert .txt file to .docx ............. libreoffice --convert-to docx file.txt

# convert .txt file to .pdf .......................... lowriter --convert-to pdf file.txt

# list only particuler extention files ...................... ls *.{png,txt}


# create pdf from multiple pictures .................... pdfjoin --a4paper --fitpaper false --rotateoversize false *.png

# remove selected files .................... rm {17,18,19,20,21}*.mp4

mv {115,215}FILE.csv ............. equal to: mv 115FILE.csv 215FILE.csv

# history with date and time ...................... echo 'export HISTTIMEFORMAT="%d/%m/%y %T "' >> ~/.bash_profile ; source ~/.bash_profile

# dark black theme add-on for firefox .................... https://addons.mozilla.org/en-US/firefox/addon/night-eye-dark-mode/


# remove tailing commas .................. echo  $entry | sed 's/,*$//g'
# download mp3 from youtube video ................. youtube-dl -x --audio-format mp3 https://youtu.be/H8YeFZXRnyg

# me ny 1 file download ki, jo .gzip format me thi, me ny kafi kosh kari k us ko unzip kar lon, magar nahi hwi, phir me ny us file ki info dekhi (file file_name.gzip) to pata chala k wo (Apache Parquet) thi, or me ny usy python me ja kar pandas me read kar lya.

cp file_1_very_large_name.rda to file_1_ver_large_name.zip ................. cp file_1_very_large_name.{rda,zip}

# say you want to remove terminal history where you use command <rm> .................... history | grep -v -w rm > .bash_history ........ and then exit from current terminal, next open terminal, now all entries were <rm> present deleted.


mv linear-regression-business-statlinear-regression-business-statistics/ .............. equal to : mv linear-regression-business-statistics{-syllabus-parsed.json,}

# read file line by line in while loop .................. input="to_download.txt";  while IFS= read -r line; do   youtube-dl "$line"; done < "$input"

--------------------------------------------------------
replace all spaces in mp3 files names to <_>:
OIFS="$IFS"
# To tell it to only split the input on newlines, you need to do
IFS=$'\n'
for file in `find . -type f -name "*.mp3"`  
do
     mv $file `echo $file | sed 's/\ /_/g'`
done
IFS="$OIFS"# merger multiple mp3 in single mp3 file ................. cat *.mp3 > final.mp3
# cut specific range from mp3 .................. sudo aptitude install poc-streamer; mp3cut -o output.mp3 -t 00:00:20+000-00:00:58+000 input.mp3 
mv CID-575-GumnaamLaash-KpPK6dLJKMA.mp4 CID-575.mp4 same as :   mv CID-575{-GumnaamLaash-KpPK6dLJKMA,}.mp4
replace every space in file name with <_> ................... mv Meri\ Qismat\ Jagane\ Ko\ Khuda\ Ka\ Naam\ Kafi\ Hai.mp3 `echo Meri\ Qismat\ Jagane\ Ko\ Khuda\ Ka\ Naam\ Kafi\ Hai.mp3 | sed 's/\ /_/g'`

# Filling the disk with all zeros ...............  dd if=/dev/zero of=/dev/sdX bs=1M ............. If you are wiping your hard drive for security, you should populate it with random data rather than zeros (This is going to take even longer than the first example.) .................. dd if=/dev/urandom of=/dev/sdX bs=1M


# zip all directories invidualy in current directory ............................ for i in `ls`; do zip -r `echo $i | sed 's/\///g'`.zip $i ; done

# unique file sizes ....................... du -sh * | cut -d "K" -f 1 | uniq
# current wifi name ....................... nmcli -t -f active,ssid dev wifi | egrep '^yes' | cut -d\' -f2 | sed 's/yes\://g'
# string comparison .................... if [ "$wifi_name"  =   "H1-Zong" ] ;  then   echo amir; fi
# move mobile\ nackup mobile\ backup ..................... equal to: mv mobile\ {n,b}ackup/

# save ok output to <ok file> and errors to <out file> ..................... ./script.sh 1> ok 2> out
# save both normal and errors outputs to <out file> ...................... ./script.sh >out 2>&1
# get your entire push history ..................... git log --pretty=format:"%ad - %an: %s" | tail
# get your entire push history (within range of dates) ..................... git log --pretty=format:"%ad - %an: %s" --after="2016-01-31" --until="2017-03-10" --author="John Doe"
copy EPUB/1-file-name.pdf EPUB/2-file-namee.pdf EPUB/3-anotherfileName.pdf Newfolder ..... equal to : cp EPUB/{1*.pdf,2*.pdf,3*.pdf} Newfolder
mv The-t{,h}ree-body-problem/ ............. equal to: mv The-tree-body-problem/ The-three-body-problem/
# compare same file sizes in two diffrent directories .............................. IFS=$'\n'; for i in `ls -d */` ; do echo "`du -sh $i;  du -sh  /media/500GB/learning/COURSES/$i`" ; done

# slecect column using awk ............... awk '{ print $1 }' foo
# select multiple columns using awk ..................  awk '{ print $1, $3 }' foo
# split the fiead by specifieng it , then select column/s ................... awk -F "|" '{ print $4 }' Notes.data
# i have lot of csv files, each file have a specific year data, i need to rename file by its 3 value on second row ......................... for i in `ls *.csv` ; do mv $i `head $i  | tail -1 | cut -d "," -f 3`; done
# sync ........................... rsync -av github/Books/ backup/
# find all .txt files .................. ls **/*.txt ------------ equal to : find . -name "*.txt"
# fine all .txt and .pdf files ..................... ls **/*.txt **/*.pdf
pass .......... while :; do : ; pass # here <:> is == pass in python

mv {working,Linux}/kali-linux-installation-guide.txt ------------ equal to : mv working/kali-linux-installation-guide.txt Linux/kali-linux-installation-guide.txt
# sort numbers .................. sort -n (eg: du -s -BK * | cut -d "K" -f1 | uniq | sort -n)
# change wifi-hotspot password ....................... nmcli connection modify Hotspot 802-11-wireless-security.key-mgmt wpa-psk 802-11-wireless-security.psk mypassword
# create hotspot and connect to it ........................... nmcli device wifi hotspot con-name Amir-hotspot ssid Amir-hotspot band bg password password123
hotspot on and off .................... sudo ap-hotspot start ................ sudo ap-hotspot stop .................... sudo ap-hotspot configure

# count single character in string ............... echo "referee" | tr -cd 'e' | wc -c (here we get 4, since 4 accours 4 times, but if we type <echo "referee" | tr -cd 'er' | wc -c>, we get 6, since r occurred twice and e occurred 4 times; 4=2=6)

# count substring in long string ........................ grep -o "amir" <<< "amirsaleemarifmoosa" | wc -l
# download youtube-dl specific quality video/s .................... youtube-dl -f 'bestvideo[height<=480]+bestaudio/best[height<=480]' -a LInk.txt ....................... https://askubuntu.com/questions/486297/how-to-select-video-quality-from-youtube-dl

# float to integer ............... float=1.23; int=${float%.*}
# replace two or more commas with one comma ................ sed 's/,\{2,\}/,/g'
# replace 1 or more space with one comma ................ sed 's/\ \{1,\}/,/g'
# zip folder .................... zip -r folder{.zip,/}
# mv  {0*,1*,2*}.png folder ..................... equal to: mv 0*.png folder ; mv 1*.png folder ; mv 2*.png folder
# to lower ................... echo "$a" | tr '[:upper:]' '[:lower:]'
mv ../URDU/{clerical*,Tasawuf*,tashkeek*} ../URDU/folder  .................. equal to: mv ../URDU/clerical* ../URDU/folder ; mv ../URDU/Tasawuf* ../URDU/folder ; mv ../URDU/tashkeek* ../URDU/folder
# change file owner
chown new_user file

# change file group
chown new_user:new_group file
# hidden files/folders to regular files/folders ................. for i in `ls -d .*?` ; do mv $i `echo $i | sed 's/.//'` ; done

# exclude from ls ....................... ls --hide "*.rar" ..................... this will list all files exclude files that ends with .rar
# unlimited history ..................... open ~/.bashrc ; assign -1 to HISTSIZE and assing -1 to HISTFILESIZE (both variables are exist, you have to change values.# add user .............. adduser new_user_name
#  ls -R is equal to `find . -name "*"` ............ NOTE: in find we get all absolute link for each file, but is hard to understand the hirarcy, on the other hand in `ls -R` you get a result like `tree`, so no absolute paths, but easy to understand the structer of the directory.
# ls -S ................... sort by size
# see in what step you copy ................ cp -v some_source_file some_other_location
# know what particuler command do ...................... whatis ........... eg: whatis cp
# change owner and group in one line ...................... chown specific_user:group2 myfile
#mplayer is a video player in linux
# totem is ubuntu default video player
# split screen horisontaly .......... gTile(install it) ; and then SUPPER+ENTER(numberpad)
# find empty folders ..................... find . -type d -empty
# get video dimentions ................... ffmpeg -i Video.mkv 2>&1 | perl -lane 'print $1 if /(\d+x\d+)/'
# get file creation date ............... ls -ltr | cut -c 31- | cut -c -6 | uniq
# cut first N characters from string .............. echo "amirsaleem" | cut -c 5- .............
# get first N characters from string .............. echo "aamirsaleemarif" | cut -c -5
# get only files created after a date with ls .................. find . -maxdepth 1 -mtime -1 .............. Note that to find files modified before 24 hours ago, you have to use -mtime +1 instead of -mtime -1
# see files names in zip file ............................ unzip -l phoneRawDataFile-28801180200957-1579799301447.zip
# remove spaces ............. echo " amir saleem " | sed 's/ //g'
# last modifieded file / folder date ............... ls -l  --time-style=long-iso | grep  raw_synced_data | sed 's/\ \{1,\}/,/g' | cut -d "," -f6,7
# long time ................ ls -l --time-style=long-iso
# rsync ....................... rsync -au 128.199.226.202:/home/amir/raw_synced_data/ raw_synced_data/
# find file/s by name, and performt particuler operation on each of them ................. eg: find Movies/ -name '*.mp4' -exec mv {} ANOTHER_FOLDER/ \; .................. NOTE: the trailink <\;> is mandatory, it is indicates the end of <-exec>

# remove all before first <#> ................ ls | grep -o '#.*'
# remove all after first <#>  ................ echo $i | grep -o '.*#'
# replace multiple characters with sed ..................... sed 's/%20/-/g; s/[][#-]//g'
# integer comparison: -eq: is equal to ........ -ne: not equal to ............ -gt: greater than ........ -ge: greater than or equal to .......... -lt: less than .......... -le: les than or equal to .......... <: less than (whithin double parentheses, eg: (("$a" < "$b"))) .............. <=: less than or equal to (whithin double parentheses, eg: (("$a" <= "$b"))) .............. >: greater than (whithin double parentheses, eg: (("$a" > "$b"))) .............. >=: greater than (whithin double parentheses, eg: (("$a" >= "$b"))) 
# sudo with password in one line (so you can write command with sudo in a script) .............. echo `cat p` | sudo -S -k nethogs
# download pip package with its dependencies ............... pip3 download package_name
# check / know you MAC (wifi) address ............. cat /sys/class/net/wlp3s0/address

# NTFS error ............... sudo umount /dev/sdb1 ; sudo ntfsfix /dev/sdb1 ; sudo mount /dev/sdb1 /media/500GB/
if you want to download only specific file from github, go to file in browser (github), press <Raw> button, and then copy the url of <Raw> file, now you can download it by wget <the url in the clipboard>
# add ssh public key to another computer to automatic authentication ............ 1- ganarate public key on your local muchine (ssh-keygen) ; 2- copy new genareted key to server: ssh-copy-id -i ~/.ssh/new_ganared_key.pub user@host# find only ascii files ............ find . -type f -exec grep -Iq . {} \; -print

# open settings ............... gnome-control-center
# replace/cahange something in file ................. sed -i 's/saleem/SALEEM/g' file.txt
# remove new line chrachters from file name .............. echo $file_name | sed ':a;N;$!ba;s/\n//g'
# check running process .............. ps aux | grep sshd 
# add file to existing zip ............... zip -u existing_zip.zip New-file
# copy clipboard to variable ........... a=`xsel -ob`
# copy variable/text to clipboard ........................ echo "copy this text to clipboard" | xclip -sel clip
# locate: locate database me search kar k matching result deta h, or wo automatic once a day update hota h, tagar aap ny 1 file abhi thori dair pehly banai h to wo aap k locate search me apear nahi ho gi, to is k lye locate sy phely ye run kar len <sudo updatedb>, 1 or masla ye hota h k mery pas 2 HDD hen, to data wali HDD ki files db nahi bani hoti, to agarcha me database ko update kar bhi dun tab bhi data HDD ki files result me show nahi ho gi, is ko solve karny k lye data HDD ko mount kar k us me chaly jaen, phir wahan ye run karen <sudo updatedb -U `pwd`>, or phir database ko update kar den, ab locate me data HDD k result bhi show hon gy.

# Run Bash script in background and exit terminal .............. nohup cmd & ............... https://superuser.com/questions/448445/run-bash-script-in-background-and-exit-terminal

# print pretty nice csv in terminal ............... cat FILE.csv | column -t -s,
# if you want to login in remote server, execute one command and then exit, you can do it in one line ......... ssh 192.168.62.12 ./exemple_script.sh
# remove_root_authentication_request_from_package .................. sudo setcap "cap_net_admin,cap_net_raw=ep" `which nethogs`
# Keep processes running after SSH session disconnects ..........................  nohup long-running-process & ...................... https://unix.stackexchange.com/questions/479/keep-processes-running-after-ssh-session-disconnects
# remove empty lines from file ................ sed '/^$/d' file.txt

uniq -c | count each unique line how many times accured
# Extract a file from a zip file .......... unzip file.zip file/you/want/to/extract/the_file.txt ........... Modify the_file.txt ............. Put it back: zip file.zip file/you/want/to/extract/the_file.txt 
# bash find only non hidden files ................... find . -not -path '*/\.*' ............. So if you're looking for a file with some text in its name, and you want to skip hidden files and directories, run: find . -not -path '*/\.*' -type f -name '*some text*' ............. Explanation: The -path option runs checks a pattern against the entire path string. * is a wildcard, / is a directory separator, \. is a dot (it has to be escaped to avoid special meaning), and * is another wildcard. -not means don't select files that match this test. ..... I don't think that find is smart enough to avoid recursively searching hidden directories in the previous command, so if you need speed, use -prune instead, like this: find . -type d -path '*/\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print .................https://askubuntu.com/questions/266179/how-to-exclude-ignore-hidden-files-and-directories-in-a-wildcard-embedded-find
# print completed file in terminal and color specific words ................ grep --color "^\|return" myfile.txt ............. https://unix.stackexchange.com/questions/57715/display-words-in-color
# create multiple files/folders at once .......... touch touch file-{a..e}.txt ....... touch file-{1..4}.txt ......... touch {a..c}-{1..4}.txt
# list files/directories only that have execution permition ......... ls -l | grep [d,-]..x

# restart mysql server ........... /etc/init.d/mysql  restart

# mysql databases location in system .......... /var/lib/mysql

#-------------------------
# redirect stderr and stdout to different files
stderr = errors outpul
stdout = normal outpul
./script.sh >normal.txt  2>errors.log
#-------------------------
# sort by second column ............ sort -k2 -n your_file
RED="\033[0;31m"
normal="\033[0m"
# sum float and int .......... sum=`echo "scale=3; $i + $sum" | bc`
#-------------------------------------------
# save sql password, so you have to type your password each time, if you need to skip this ; do:
1- sudo cp /etc/mysql/my.cnf ./.my.cnf
2- open ./.my.cnf
3- type these line in the end:
[client]
password=type_you_password_here

#swape rows in print, print lines in reverse orders, last become first and first become last one .........  echo -e "my\nname\nis\namir" | tac
# to avoid <“System problem detected”> popup, do: sudo rm /var/crash/*
# variable increment ........ count=5; let "count+=1" ............ another way: let "count++" ............... another way: let count ++ .................. CAUTION........... me 1 script chala raha tha (bash --version:  ) to us me loop me condition k andar encrement ho raha tha, to wahan srif <let "m++"> sahi chal raha tha, or <let "m+=1"> sahi nahi chal raha tha.

check if two files are identical .......... cmp --silent $old $new || echo "files are different"
#-----------------------
zip file in tar:
Following are 5 commonly used options – c, z, f, v, x

    c = create a new tar file
    v = verbose , display file to compress or uncompress
    f = create the tar file with filename provided as the argument
    z = use gzip to zip it
    x = extract file

tar -cvz My_csv.csv -f My_csv.tar
# find .py files and copy each file to ~/abc ............ find . -name *.py | xargs -I{} cp -v {} ~/abc/
# ganerate range using variable ............. for i in $(seq 1 $END); do echo $i; 
# email to your address ........... echo "BODY" | mail -s "Subject"  amirsaleem1990@hotmail.com
# logout ............... pkill -KILL -u `hostname`
# How to change default crontab editor .................... export EDITOR=/bin/nano; export VISUAL=nano
# list all *txt files except *3txt ............. ls ./*[!3]txt ........... ls *[^3]txt
# remove all numbers ............ sed 's/[0-9]//g'

# <unzip -l> return file size in bytes
# ubuntu terminal me ls karny sy urdu/arabic names reverce me display hoty hen jin ko parrhan bohot hi mushkil hota h, is lye jahan arabic names hon wahan ye use karen ............ ls | fribidi
# poora folder (recursively) copy karna hy magar srif .jpg files nothing else..... cp --parents `find -name \*.jpg*` ~/target_directory/
# sum of column ......... <cmd> | paste -sd+ | bc .......... eg: cat All_FB_links_names_corrected.csv | cut -d, -f1 | sort | uniq -c | sed 's/^      //g' | grep -v ^1  | cut -d " "  -f1 | paste -sd+ | bc

# compare floats ...... num1=3.17648E-22; num2=1.5; echo $num1'>'$num2 | bc -l; echo $num2'>'$num1 | bc -l

# Change string char at index X .................... echo $theStr | sed s/./A/5 ............... First you pipe the output of $theStr to sed, which replaces the fifth character with A. ............... another style: theStr="${theStr:0:4}A${theStr:5}"

# merge two files line by line ............... paste file1.txt file2.txt > fileresults.txt

# round a number ........... printf "%.0f\n" 123.456 ............ echo 123.456 | awk '{print int($1)}' ................. for floar: echo 1.23 | awk '{print int($0)}' ............ for ciel: echo 1.23 | awk '{print ($0-int($0)>0)?int($0)+1:int($0)}' ................ 

#--------------------------
# diffrence between two dates
last_done_date=`ls -tr /home/amir/Summary/ | tail -1 | sed 's/summary_atteched_files_//g' | cut -d_ -f1 | sed 's/-//g'`
current_date=`date +%F | sed 's/-//g'`

let DIFF=(`date +%s -d $current_date`-`date +%s -d $last_done_date`)/86400
echo $DIFF
#--------------------------
# groupby and then count (same as pd.Series.value_counts() in pandas) .............. sort ip_addresses | uniq -c
# replace multiple characters at once ............ echo "hamza&amir@saleem*arif(moosa)" | sed 's/[@&*()]/ /g' ................ hamza amir saleem arif moosa
# trycatch ................ command1 || command2 <if command1 fails then command2 runs as follows> ................. command1 && command2 <command2 will run if command1 is successful>
# simulate keyboard input ............... https://unix.stackexchange.com/questions/267704/command-to-simulate-keyboard-input ................. xdotool key <key> (eg: xdotool key ctrl+c) ............... To simulate pressing ctrl + c and then a Backspace: xdotool key ctrl+c BackSpace 
# switch to next/previous application : https://askubuntu.com/questions/961082/command-to-switch-to-next-previous-application ............. list the windows being managed by the window manager: wmctrl -l ............. switch to the desktop containing Firefox, raise the window and give it focus: wmctrl -a firefox ............. 
# check linux os installation date .............. dumpe2fs /dev/sda1 | grep 'Filesystem created:' .............. sudo tune2fs -l /dev/sda1 | grep -i Created


# virtualbox ki linux sy host linux ssh sy connect ho sakti h.
# ssh k lye user name `whoami` sy find karty hen

#------------------------
# cron
# add cron job: crontab -e ; now add jobs, then exit
# to list cron jobs : crontab -l

# add directory to path ............... write this line into ~/.bashrc: PATH="/amir_bin/:$PATH" , and then run <source ~/.bashrc> ......... 
# check os version ......... cat /etc/os-release
# print two files side by side ................ diff -y   File_1.txt File_2.txt


# How to copy Docker images from one host to another without using a repository
# https://stackoverflow.com/questions/23935141/how-to-copy-docker-images-from-one-host-to-another-without-using-a-repository
You will need to save the Docker image as a tar file:
> docker save -o <path and file_name for generated tar file> <image name>
Then copy your image to a new system with regular file transfer tools such as cp, scp or rsync(preferred for big files). After that you will have to load the image into Docker:
> docker load -i <path to image tar file>
# open craontab in nano .............. EDITOR=nano crontab -e

# check PID using command executed ......... pgrep script_name
# check PIDs using package ................. pgrep -l python3


# check script output using PID in /proc/ ................ tail -f /proc/$PID/fd/{0..3}*

# jab alias and koi program 1 hi name k hoty hen, or ham wo command type karty hen to alias execute hota h

# <eog> is default image viwer in ubuntu
# logout ........... gnome-session-quit --no-prompt


change tabl ........... CTRL+SHIFT+TAB   and CTRL+TAB

# ksi packages ki help k lye ............ package_name --help  , help package_name  ,  man package_name   ,   info package_name

ls -X ........ sort by extention


# replace .html and all after it with .html ......... sed 's/html.*/html/'
# find and then ls (long) .......... find . -name "*.html" -ls
# change command line prompt .......... change PS1 variable, eg: PS1="This is a new prompt: "

# ls hidden file for particuler direcotry/folder ...... ls -d github/.*
#-----------------------
Nested if else in one line, These two codes are does the same job:
1- 
			for re in 1 0 2 1; do 
				if [[ $re == 0 ]]; then
					echo -e "Disconnected VPN successfully"
				else
					if [[ $re == 1 ]] ; then
						echo -e "Disconnected VPN successfully"
					else
						echo "d"
					fi
				fi
			done
2- 
			for re in 1 0 2 1; do
				[[ $re  == 0 || $re == 1 ]] && echo -e "Disconnected VPN successfully" || echo "d"
			done
#-----------------------

# redirect stderr and stdout to a file .......... command > file 2>&1

#-----------------------
# I have a file like this:
NODE_1_length_4014_cov_1.97676  1   1
NODE_1_length_4014_cov_1.97676  2   1
NODE_1_length_4014_cov_1.97676  3   1
NODE_1_length_4014_cov_1.97676  4   1
NODE_1_length_4014_cov_1.97676  5   1
NODE_1_length_4014_cov_1.97676  6   1
NODE_1_length_4014_cov_1.97676  7   1
NODE_1_length_4014_cov_1.97676  8   1
NODE_1_length_4014_cov_1.97676  9   1
NODE_1_length_4014_cov_1.97676  10  1

I want to split the first column into new columns based on the character '_', like this:
1 4014 1.97676  1   1
1 4014 1.97676  2   1
1 4014 1.97676  3   1
1 4014 1.97676  4   1
1 4014 1.97676  5   1
1 4014 1.97676  6   1
1 4014 1.97676  7   1
1 4014 1.97676  8   1
1 4014 1.97676  9   1
1 4014 1.97676  10  1

ANS: 
> awk -F'_' '{print , ,,,}' infile
1 4014 1.97676  1   1  
1 4014 1.97676  2   1  
1 4014 1.97676  3   1  
1 4014 1.97676  4   1  
1 4014 1.97676  5   1  
1 4014 1.97676  6   1  
1 4014 1.97676  7   1  
1 4014 1.97676  8   1  
1 4014 1.97676  9   1  
1 4014 1.97676  10  1
#-----------------------
du with hidden files ............. du -sch .[!.]* * 
# unzip .7z files ............. 7za e zip_file_name.7z

# update pip package ........... pip3 install -U youtube-dl
# grep ........... search "cpu" or "ram" in all files in current directory .......... grep -i -e cpu -e ram -r .  ..................... which is equelent to: grep -i "cpu\|ram" -r . 
# Find all files under the /tmp directory that are newer than an already existing file and give a detailed listing ................. find /tmp -newer /tmp/tstfile -ls ................ where it is assumed you will substitute the name of an existing file for /tmp/tstfile.
# Find all subdirectories under the /etc directory: ..................... find /etc -type d
# Find all files/folder that  ends with cfg ........... locate -r "cfg$" 
# The tac command (cat spelled backwards) prints the lines of a file in reverse order. Each line remains the same, but the order of lines is inverted. The syntax of tac is exactly the same as for cat
# Append a file to the end of an existing file .............. cat file >> existingfile 
# write / append in file ............. wirte (cat > file_name) OR (cat >> file_name) ..... wirte lines you want and then press Ctrl-D
# sed -e command <filename> ..................... Specify editing commands at the command line, operate on file and put the output on standard out (e.g. the terminal)
# sed -f scriptfile <filename> .................. Specify a scriptfile containing sed commands, operate on file and put output on standard out
# sed 1,3s/pattern/replace_string/g file ........ Substitute all string occurrences in a range of lines

# awk 'command'  file	............ Specify a command directly at the command line
# awk -f scriptfile file ........... Specify a file that contains the script to be executed
# awk '{ print $0 }' /etc/passwd ... Print entire file
# awk -F: '{ print $1 }' /etc/passwd ... Print first field (column) of every line, separated by a space
# awk -F: '{ print $1 $7 }' /etc/passwd ..... Print first and seventh field of every line

# sort -k 3 <filename> ..... Sort the lines by the 3rd field on each line instead of the beginning

# remove duplicate entries from multiple files at once, use the following command: ............... sort file1 file2 | uniq > file3 ........... sort -u file1 file2 > file3
# colbind all csv files delimetid with <,>................. paste -d, *.csv
# <join> the enhanced version of <paste>. it first check weather the files share common feilds, such as nume or phone numbers, and then join the lines in two files based on common field.
# split ................. split large file by size/lines. by default is split file by 1000 lines.
# grep [0-9] <filename> ...........  Print the lines that contain the numbers 0 through 9
# grep -C 3 [pattern] <filename> ... Print context of lines (specified number of lines above and below the pattern) for matching the pattern; here, the number of lines is specified as 3
# tee ................ tee takes the output from any command, and, while sending it to standard output, it also saves it to a file. In other words, it "tees" the output stream from the command: one stream is displayed on the standard output and the other is saved to a file.
# if in multiple (equivalent) ways .......... if [[ -f file.c ]] ; then ... ; fi ..........if [-f file.c] ;then...;fi ............ if test -f file.c ; then ... ; fi ............... The first form with double brackets is preferred over the second form with single brackets, which is now considered deprecated. ........... The test form is also deprecated for the same reason and it is more clumsy as well. However, it is common to see these older conditional forms in many legacy scripts.

# if [ $VAR == "" ] ..... will produce a syntax error if VAR is empty, so you have to do: ....... if [ "$VAR" == "" ]


# make && make modules_install && make install ................. The &&s (ANDs) say stop as soon as one of the commands fails
# [[ -f /etc/foo.conf ]] || echo ’default config’ >/etc/foo.conf ........... he ||’ (ORs) says stop as soon as one of the commands succeeds.

[[ $STRING == mystring ]] && echo mystring is "$STRING" ..... is equivalent to ............. if [[ $STRING == mystring ]] ; then echo mystring is "$STRING"; fi

# Arithmetic Comparisons ................ -eq, -ne, -gt, -ge, -lt, -le
# decrement/increment ............. variable=$(($variable - 1 )) ............. variable=$(expr $variable - 1)
#--------------------
# case 
#!/bin/sh
echo "Do you want to destroy your entire file system?"
read response
case "$response" in
   "yes")              echo "I hope you know what you are doing!" ;;
   "no" )              echo "You have some comon sense!" ;;
   "y" | "Y" | "YES" ) echo "I hope you know what you are doing!" ;
                       echo ’I am going to type: " rm -rf /"’;;
   "n" | "N" | "NO" )  echo "You have some comon sense!" ;;
   *   )               echo "You have to give an answer!" ;;
esac
exit 0
#--------------------
# find . -name "*.o" -exec rm {} ’;’ ............... equivalent to ............. find . -name "*.o" | xargs rm
# There is <until> loop, which is same as while (in syntax and working (as my understanding))
#-----------------------
# function
function fun_foobar(){
   statements
}

OR
function fun_foobar{
   statements
} # This syntax will work fine in bash scripts, but is not designed for the original Bourne shell, sh.
  # In the case where a function name is used which collides with an alias, this method will still work.
In most cases, use of the function keyword is not often used in new scripts.
#-----------------------END

# function me jo variable define hota h wo gloabl me chala jata h.
# find with du ............. du -sh `find . -name "*.sh"` ............... find . -name "*sh" | xargs du -sh ................ find . -name "*sh" -exec du -sh {} \;
#-----------------
Network devices are somewhat different, but almost everything else works just as a file. Even network devices use a file paradigm when you work with what are known as sockets. One important point is that in most cases, Linux does not care about file extensions, whatever follows the dot sign. It doesn't assume that if it's .jpg, it's an image, for instance. It actually looks at the file and determines that. There are a few exceptions to this. Sometimes, compilers look at the extension and decide whether it's a C++ file, whether it's a Fortran file, or whatever, so it knows how to compile it. But that can always be overwritten, even though it's a default. So, that's just a little bit about how Linux deals with different file types. 
-------------
chmod uo+x,g-w a_file ................  to give the owner and world execute permission, and remove the group write permission ............ where u stands for user (owner), o stands for other (world), and g stands for group.......... This kind of syntax can be difficult to type and remember, so one often uses a shorthand which lets you set all the permissions in one step. This is done with a simple algorithm, and a single digit suffices to specify all three permission bits for each entity. This digit is the sum of: 4 if read permission is desired. 2 if write permission is desired. 1 if execute permission is desired. ..... Thus, 7 means read/write/execute, 6 means read/write, and 5 means read/execute.
# You can change owner and groupd at the same time: ............ chown user.group a_file ............. chown user:group a_file
# chwon can take an -R option, which stands for recursive.
#------------ 
# change default files permition  using umask
# checek current umask ........ umask
# umask u=r,g-w,o=rw ........ user will read only, group will write only, and others will read and write
# see '/home/amir/github/Linux/What is Umask and How To Setup Default umask Under Linux_ - nixCraft.html'

# skip last line ............. sed '$ d'
#------------------------------------------------
# https://www.cyberciti.biz/faq/unix-linux-bash-script-check-if-variable-is-empty/
# check if variable is empty/defined
[ ! -z "$var" ] || echo "Empty"
[ ! -z "$var" ] && echo "Not empty" || echo "Empty"
 
[[ ! -z "$var" ]] || echo "Empty"
[[ ! -z "$var" ]] && echo "Not empty" || echo "Empty"
#------------------------------------------------# show OS related details ......... lsb_release -a

# make all hidden files/directories to normal (non-hidden) files/directories ......... for i in `ls -a | sed 1d | sed 1d`; do mv $i `echo $i | sed s:^.::g` ;done

# <nohup COMMAND &> is lye use hota k agar aap logout bhi kar len tab bhi aap ka program chalta rahy, isi kam k lye <screen> bhi use hota h. <scrren> type kar k enter karen, existing terminal clear ho jay ga, ab is terminal par apni script run karun eg: ./MYSCRIPT ... ab CTRL press karty hwy A press karen, or phir in dono ko chor kar k D press karen. aap dubara apni purany terminal par wapis aa jaen gy (jahan <screen> command run karny sy pehly thy). ab agar aap ny dupara usi terminal par jana h jahan aap ny apni script chalai h to <screen -r> karen. agar multiple screens hen to <screen -r> aap ko list dy dy ga k ye screens availible hen, aap un me sy koi 1 select kar ky us me enter ho jaen. screen ko khatam karny k lye ya to parent terminal par screen -d screen_id likhen, ya us screen me jar ka <exit> kar den. agar aap ny screen exit kar di to us ki command destroy ho jay gi. in conclusion: screen >> ./SCRIPT.py >> CTRL+A+D ..... ab me apni orignal terminal par hun, agar me is terminal sy exist kar deta hun, or server sy mera connetion khatam bhi ho jata tab bhi screen/s server par exist karen gi.

# copy text selected area ........... agar hamar pas terminal khula hwa h or us me ye content h:
-rwxrwxr-x 2 amir amir  1410 Dec 26 23:13  copy_speed*
-rwxrwxr-x 2 amir amir   485 Dec 26 23:13  connect_to_wifi*
-rwxrwxr-x 2 amir amir  1678 Dec 26 23:13  connected_devices_info*
-rwxrwxr-x 2 amir amir   847 Dec 26 23:13 'compere file sizes between two directories.sh'*
-rwxrwxr-x 2 amir amir  1169 Dec 26 23:13  check_uniqe_file_extentions*
-rwxrwxr-x 2 amir amir   976 Dec 26 23:13  battery*
-rwxrwxr-x 2 amir amir   923 Dec 28 11:31  Connect_to_Kashet_server*
-rwxrwxr-x 2 amir amir  1031 Dec 30 18:59  kurulus_usman_next_episode_on_eir_date*
-rwxrwxr-x 2 amir amir  2347 Dec 31 14:46  git_status*
lrwxrwxrwx 1 root root    57 Jan  4 11:33  naclient_reconnect -> /home/amir/github/Linux/bin/functional/naclient_reconnect*

or hamen srif user group tak ka sara data lena h, (yani k har line me group k bad ka koi data nahi chahye CTRL daba kar rakhen or particuler area select kar k copy kar den.
# Kill detached screen session ......................... screen -X -S [session # you want to kill] quit

# find files by users vivek and wendy ............. find / -user vivek -o -user wendy
# convert seconds to day, hours, minutes, secons .................. eval "echo "
# convert seconds to day, hours, minutes, secons .................. eval "echo "

# convert seconds to day, hours, minutes, secons .................. eval "echo $(date -ud "@$SEC" +'$((%s/3600/24)) days %H hours %M minutes %S seconds')"

# check if library is installed ......... which ffmpeg > /dev/null || { echo "Install ffmpeg, with 'sudo apt-get install ffmpeg'" >&2; exit 1; }

# unique owners of files and directories .............. find  .  -printf "%u\n" | sort | uniq -c

# find for multiple extentions ........... find . -regextype posix-egrep -regex ".*\.(aac|m4a)$" .............. find . -name "*.aac" -or -name "*.m4a" ..........  find . \( -name \*.py -o -name  \*.ipynb \) ............... ALL return the same value
# convert webm to mp4 ............... ffmpeg -i video.webm -crf 26 video.mp4
get only specific range of lines ................. sed -n '16224,16482p;16483q' filename > newfile ................. https://stackoverflow.com/questions/83329/how-can-i-extract-a-predetermined-range-of-lines-from-a-text-file-on-unix
# another pdf reader .............. okular

# convert epoch seconds to date time ............ date -d  @1612762179

# install .deb file using:
#### gdebi (gdebi application.deb)
#### dpkg  (dpkg -i application.deb)




# calculator ......... echo 40/2+401 | bc ........... echo "scale=3;  90/2.6 " | bc
# find all unique owners of files/folders ............ find /data/raw_synced_data/ -printf "%u\n" | sort -u
# get length of variable ........... myvar="my name"; size=${#myvar}; echo $size

# sort ps by cpu ........ ps --sort=-pcpu

# date -d '2021-03-09 08:10' +'%s' ......... Convert datetime to epoch seconds

# google chrome bookmarks .......... /home/amir/.config/google-chrome/Default/Bookmarks

# recover lost data ............ photorec
# get pixels (width and height) of an image ............ identify -format '%w %h' img.png ; identify -format '%w %h' img.png ; identify img.png
# Input/output error ................ 1 folder delete nahi ho raha tha (Input/output error), me ny as a root logoin ho kar bhi try kya magar wo delete nahi hwa, phir me ny <sudo nautilus .> kya, or phir us directory ko mouse sy click kar k delete ka button dabaya to wo delete ho gai


get ipv-4 address ......... ip -4 addr ......... # <inet> means ipv4 address
get ipv-6 address ......... ip -6 addr ......... # <inet6> means ipv6 address



#extract rar files to folder .............. rar x archive.rar path/to/extract/to

# extract zip file ................. /home/amir/github/Linux/'command line - Having trouble uncompressing a few files.html'

# Get autocompletion when invoking a “read” inside a Bash script .............. read -e -p "Your prompt:" var_name
# bash read input autocomplete ................. read -e -p "Your prompt:" var_name

save a frame as a jpeg file every 5 seconds  ............ mplayer -vo jpeg -sstep 5 file.avi
get epoch time for give date and time .............. date --date '2017-08-17 04:00:01' +%s    # "1502938801" 
# recersive grep .................... find in all subdirectories (maximum depth) ............. grep -r YOUR_PATTERN
# problem: mkdir: cannot create directory ‘blabla’: Read-only file system .................... solution: sudo mount -o remount,rw '/media/amir/320GB'

#---------------------
# merge multiple lines into one line 
>>> cat input.txt 
# I came
# I saw
# I conquered!

Join Without a Delimiter and With a Single Character Delimiter:
	>>> readarray -t ARRAY < input.txt; IFS=''; echo "${ARRAY[*]}")
	# I cameI sawI conquered!
Join With a Multiple Character Delimiter:
	>>> readarray -t ARRAY < input.txt;  printf -v TXT  "%s; " "${ARRAY[@]}"; echo ${TXT%; }
	# I came; I saw; I conquered!
Join Without a Delimiter:
	>>> tr -d '\n' < input.txt 
	# I cameI sawI conquered!
Join With a Single Character Delimiter:
	>>> tr '\n' ',' < input.txt | sed 's/,$/\n/'
	# I came,I saw,I conquered!
Join Without a Delimiter and With a Single Character Delimiter:
	>>> paste -sd '' input.txt 
	# I cameI sawI conquered!

	>>> paste -sd ',' input.txt
	# I came,I saw,I conquered!
Join With a Multiple Character Delimiter:
	>>> paste -sd "@#" input.txt
	# came@I saw#I conquered!
The sed Command:
	>>> sed ':a; N; $!ba; s/\n//g' input.txt 
	# I cameI sawI conquered!
	
	>>> sed ':a; N; $!ba; s/\n/,/g' input.txt 
	# I came,I saw,I conquered!
	
	>>> sed ':a; N; $!ba; s/\n/; /g' input.txt 
	# I came; I saw; I conquered!

The awk Command:
	>>> awk -v d="" '{s=(NR==1?s:s d)$0}END{print s}' input.txt
	#I cameI sawI conquered!

	>>> awk -v d="," '{s=(NR==1?s:s d)$0}END{print s}' input.txt
	#I came,I saw,I conquered!

	>>> awk -v d="; " '{s=(NR==1?s:s d)$0}END{print s}' input.txt
	#I came; I saw; I conquered!

#------------ END

# # Create array in loop from number of arguments ............ args=(); for i in "$@"; do args+=("$i"); done ............ alternative: args=("$@") ............. now access any value of the arry by its index (statrtin from 0, to -1 ..... echo "${args[0]}"; echo "${args[-1]}"; echo "${args[@]}"

#----------------
#How to convert Python code to executable file?
pip3 install pyinstaller
pyinstaller myscript.py
# PyInstaller should create a dist folder where your executable file is and all other files that need to be included in your distribution.
# for further details check /home/amir/github/Linux/Using-PyInstaller-PyInstaller-4.3-documentation.html
# https://pyinstaller.readthedocs.io/en/stable/usage.html
#-------------END

# ---------------
# convert .py to .pyc
python3 -m compileall -b <pythonic-project-name>
python3 -m compileall .  
python3 -m compileall MY_script.py
# ------------END

# search of unique owners of files and directories .................. find <path> -printf "%u\n" | sort -u .................... find <path> -printf "%u\n" | gawk '1{u[$0]=1;} END{ for (x in u){print x;}}'

# exclude/remove all non-numeric | keep only numeric ............ echo "Â10.41.89.50-._ " | tr -cd '[:alnum:]'  

# Colors missing when calling grep through script .......... To preserve the colouring, add the --color=auto flag to the grep command inside the script (eg. cat file | grep --color=auto '\|RAM\|CPU')

#-----------------------
# get firefox bookmarks ............... 
sqlite3 /home/amir/.mozilla/firefox/65oyq9jg.default-release/places.sqlite "
	select moz_places.url, moz_bookmarks.title
	from moz_places, moz_bookmarks
	where moz_bookmarks.fk = moz_places.id
	and moz_bookmarks.type = 1
	and length(moz_bookmarks.title) > 0
	order by moz_bookmarks.dateAdded"
#--------------------END


echo $(cat file_name) ............ concatenate multiple lines of output to one line 
turn on  bluetooth ................ rfkill unblock bluetooth
turn off bluetooth ................ rfkill block bluetooth


query local sqlite file ........... sqlite3 my_db.sqlite "select * from my_table where hour=6;"

get string variable length ........... echo ${#var_name}

<<<<<<< HEAD




# https://www.youtube.com/playlist?list=PLzMcBGfZo4-nUIIMsz040W_X-03QH5c5h
netstat -a ................ list all listening ports for TCP and UDP connections.
netstat -at ............... list all TCP port connections.
netstat -l ................ list all active ports.
netstat -u ................ list all UDP port connections.


curl URL ............................................ sends get   request to the URL
curl -X POST URL .................................... sends posrt request to the URL 
curl -X POST --data "p1=value_1&p2=value_2" URL ..... sends posrt request to the URL with perameters
curl -X POST --d p1=value_1 -d p2=value_2   URL...... sends posrt request to the URL with perameters
curl -I URL  ........................................ get header
curl --header "key:value" -X POST  .................. send cutom header with post request 



on server:
	chmod a+rwx,u-x,g-rwx,o-rwx ~/.ssh/authoriezed_keys
	OR
	chmod 600 authoriezed_keys

	chmod a+rwx,g-rwx,o-rwx ~/.ssh
	OR
	chmod 700 ~/.ssh

to access server from your computer copy your rsa.pub to server at ~/.ssh/authoriezed_keys

passphrase:
	jab ham rsa key ganerate karty hen to hamary sy <Enter passphrase> mangta hy, agar ham is me apni taraf sy koi bhi phrase dal den (eg: 12MYphrase34), to jab ye ganerated public key ksi server par jay gi, or me us server ko connect karun ga, to pehly to wo keys match kary ga k us k pas jo public key h us ki private key mery system par h ya nahi, agar h to ab second phase ye ho ga k wo mery sy ye phrase (12MYphrase34) mangy ga, agar me ny nahi dya to connection nahi ho ga.
	ye phrase is lye hota h k agar aap ki public and private keys ksi k hath lag bhi jayen tab bhi wo server ko connect na kar saky.


Envoirment variables:
	env .................. see all Envoirment variables.
	printenv env_variable_name ...... print Envoirment variable value ........... eg: printenv HOME
		OR
		echo $env_variable_name ..... eg: echo $HOME
	set Envoirment variable:
		for current session only:
			export my_env_var=my_value
		perminently (only for this user):
			echo -e "\nexport my_env_var=my_value\n" >> ~/.bashrc; source ~/.bashrc
		perminently (globaly, for all users)
			echo -e "\nexport global_env_var=global_value\n" >> /etc/environment; source /etc/environment
	remove Envoirment variable:
		for current session only:
			unset my_env_var
		perminently (only for this user):
			remove it from ~/.bashrc and then source the file
		perminently (globaly, for all users):
			remove it from /etc/environment and then source the file


nano:
	copy:
		1- jahan sy copy karna start karna h wahan par curson ly jayen.
		2- press CTRL+6
		3- select needed portion
		4- press ATL+6
	cut:
		do first 3 steps as in <copy section above>
		4- press CTRL+K
	paste:
		press CTRL+U


vim:
	i      - go into insert mode:
	Esc    - go back to command mode:
	:wq    - (in command mode) save and quit
	:q!    - (in command mode) quit without saving
	v      - (in command mode) go into heilight mode
	y      - (in heilight mode) copy heilighted portion
	p      - (in command mode) paste
	d      - (in heilight mode) delete heilighted portion
	u      - undo
	CTRL+r - redo
	w      - (in insert mode) go to next word
	b      - (in insert mode) go to back work
	0	   - (in insert mode) go to beggining of the line
	SHIFT+4- (in insert mode) go to end       of the line


sudo <s(uper)u(ser)do>:
	stands for: super user do
	if you are in sudo group you have access to sudo commands.


grep:
	grep a.  file.txt ............ a followed by anything, so ignore lines with only <one a withoud leading and tailing space>
	grap a.a file.txt ............ a followed by anything and then again a
	grep [a,b].a file.txt ........ anything statrts with a or b,, then anyting and then a
	grep -o abc file.txt ......... show only matching patterns, not entire lines
	grep -r hello /home/amir ..... search hello in all /home/amir/sub_direcoties !!!!!!!!!!!!!!!!!!!!!!! VERY IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!
	
chomd +x file.txt ................... give execution permition to user,group and all
chmod -r file.txt ................... remove reading permition to user,group and all
functions:
	func_1(){
		echo "function called!"
	}

	func_1 # call the function


	func_2(){
		echo "Argument#1: $1, Argument#2: $2, Argument#3: $3"
	}
	func_2 amir              # Argument#1: amir, Argument#2: , Argument#3:
	func_2 hamza amir        # Argument#1: hamza, Argument#2: amir, Argument#3:
	func_2 hamza amir saleem # Argument#1: hamza, Argument#2: amir, Argument#3: saleem


variables cannot have:
	- Exclamation points
	- spaces
	- statrt with numbers



if, elif and else:
	if [[ $x = "amir" ]]; then
		# do something
	elif [[ $x = "danish" ]]; then # !!!!!!!!!!!!!!!!!!!!!!! VERY IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!
		# do something
	else
		# do something
	fi


Cron job Vs crontab:
	crontab:
		specific to each user.
		Every user on the system has one.
	cron job:
		it is a command that is scheduled to run at specific time.
		cron job is managed by crontab

crontab:
	min(0-59), hour(0-23), day-of-month(1-31), month(1-12), day-of-week(0-6)<0 for sunday, and 7 is also sunday>
	*/1     *  * *   *   command # execute <command> every 1 minute
	*   */1    * *   *   command # execute <command> every one hour
	0   */4    * *   *   command # execute <command> every 4   hours
	*/15    *  * *   *   command # execute <command> every 15 minutes
	15      *  * *   *   command # execute <command> at 15 minutes (ye 1 din me 24 times chaly gi, har ghanty me 15 minutes par)
	5,10,15 *  * *   *   command # execute <command> at 5,10,15 minute (ye command har ghanty me 3 time chaly gi, 5th, 10th and 15th minutes for each hour)
	0       *  * *   *   command # execute <command> at every hour (0th minute)
	0       0  * *   *   command # execute <command> at every day (0th minute and 0th hour)
	0		5  * *   *   command # execute <command> at every day at 05:00 AM
	30      10 1 */3 *   command # execute <command> at every 3 months on the 1st at 10:30 AM
	0       0  * *   1-5 command # execute <command> at every monday to friday at 00:00 AM
	@daily               command # execute <command> at every day midnight # the default setting for <@daily> is midnight, so at default it is the same as (@midnight)
	@midnight            command # execute <command> at every day midnight
	@reboot              command # execute <command> at every reboot 
	@weekly              command # execute <command> at every 
	@annually            command # execute <command> at every 
	@yearly              command # execute <command> at every 
	@hourly              command # execute <command> at every 
	@monthly             command # execute <command> at every 


uptime (uptime for the system):
	>>> uptime 
	# 14:57:11 up 18:46,  1 user,  load average: 1.52, 1.39, 1.24

wall:
	broadcast a massage to all currently logged in users
	wall "hello users"

	wall  displays a message, or the contents of a file, or otherwise its standard input, on the terminals of all currently logged in users.  The command will wrap lines that are longer than 79 characters.  Short lines  are whitespace  padded  to have 79 characters.  The command will always put a carriage return and new line at the end of each line.

	Only the superuser can write on the terminals of users who have chosen to deny messages or are using  a  program which automatically denies messages.

	Reading from a file is refused when the invoker is not superuser and the program is set-user-ID or set-group-ID.


wirte user_name:
	write to specific user:
		write user_name # and hit Enter
		no every line you type will show at user_name terminal

mesg:
	mesg y .......... enable  wrrte  
	mesg n .......... desable write # no one cat <write> to you

who ...................... list alll loged-in users

shutdown:
	shutdown -h now ................... shutdown immediatly
	shutdown -h +10 ................... shutdown after 10 minutes
	shutdown -r now ................... restart immediatly
	

rdfind . .................. find duplicated files
get perameters in script ........... /home/amir/github/Linux/'Use Command Line Arguments(Perameters) in a Bash Script.sh'
=======
kill 121,323,2323 ................ kill multiple PIDs at once
service --status-all (note: + mean running services, and - means stoped services )............. list all services 

ssh multiple commands single line ......... ssh user_name@ip "./first_script; ./second_script; ls -ltr"

>>>>>>> e3740279319983ab20f2142cf1e4f1b8b510bd64
#  loop over arguments from terminal .............. for var in "$@"; do echo "$var" ; done

# get last character from string ...................... echo "${var_name: -1}"

iterate over arguments in script .............. for var in "$@"; do echo "$var"; done

chage ................ change user password expiry information
chage -l amir ........ show amir user password expiry information


# find with long command ............. find . -name "*.mp4"  -exec bash -c  'for f; do du -sh  "" ; done' _ {} \;

read .txt file withing zip file (withoud unzipping) ................. unzip -p zip.zip file.txt 

# erase complete drive (not a partition) ............. sudo shred -v -n1 -z /dev/sdX (replace <sdX> with your device name)

# bash modulo if ..................... if ! ((n % 4)); then echo "$n divisible by 4."; fi .................. if [ $(( $a % 4 )) -eq 0 ]; then ..................... if [[ $(( $1 % 4 )) == 0 ]]; then ................. ((a%4)) && echo "$a is not divisible by 4" || echo "$a is divisible by 4" 

# Convert seconds to hours, minutes, seconds ......................... date -d@$57024 -u +%H:%M:%S

# How to download package not install it with apt-get command? .................. sudo apt-get install --download-only package_name ............. This will download pppoe and any dependencies you need, and place them in /var/cache/apt/archives. That way a subsequent apt-get install pppoe will be able to complete without any extra downloads.

